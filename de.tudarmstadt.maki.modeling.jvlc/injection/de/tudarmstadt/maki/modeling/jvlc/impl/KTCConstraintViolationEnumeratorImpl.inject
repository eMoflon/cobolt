
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

partial class KTCConstraintViolationEnumeratorImpl {



@model reportViolation (KTCLink link1, KTCLink link2, KTCLink link3) <--

		// Empty default implementation
-->

@model checkConnectivityViaActiveLinks (Graph graph) <--

		if (graph.getNodeCount() == 0) {
			return true;
		}

		final Node node = graph.getNodes().get(0);
		final Set<String> visited = new HashSet<>();
		final Deque<Node> toBeVisited = new LinkedList<>();
		toBeVisited.add(node);

		while (!toBeVisited.isEmpty()) {
			final Node currentNode = toBeVisited.pop();
			visited.add(currentNode.getId());
			for (final Edge edge : currentNode.getOutgoingEdges()) {
				if (((KTCLink) edge).getState() == LinkState.ACTIVE && !visited.contains(edge.getTarget().getId())) {
					toBeVisited.add(edge.getTarget());
				}
			}
			for (final Edge edge : currentNode.getIncomingEdges()) {
				if (((KTCLink) edge).getState() == LinkState.ACTIVE && !visited.contains(edge.getSource().getId())) {
					toBeVisited.add(edge.getSource());
				}
			}
		}
		return visited.size() == graph.getNodeCount();
-->

}